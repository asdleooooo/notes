# es6

## 声明新增
### let
- 声明一个作用域为`块级作用域`的变量
- 不会作为window的属性
- 不会变量提升
- 不能重复声明
### const
- 声明一个作用域为`块级作用域且只读`的常量
- 不会作为window的属性
- 不会变量提升
- 不能重复声明
### 块级作用域
ES5只有全局作用域和函数作用域，没有块级作用域
- 内层的变量可能会覆盖外层变量 
  ```js
  var tmp = new Date();

  function f() {
    console.log(tmp);
    if (false) {
      var tmp = 'hello world';
    }
  }

  f(); // undefined
  ```
- 循环函数变量会泄露为全局变量
  ```js
  var s = 'hello';

  for (var i = 0; i < s.length; i++) {
    console.log(s[i]);
  }

  console.log(i); // 5
  ```
#### 声明变量的六种方式
- var
- function
- let
- const
- import
- class  
一共这六种声明变量的方式


### 顶层对象属性
在浏览器环境下，是window变量，在node的环境下，是global对象
`顶层对象的属性与全局变量等价`

## 解构赋值
- 解构不成功，变量的值就是`undefined`
- 本质上是匹配模式，左右两边结构相同，右边的值就会赋值到对应的变量上
- 解构赋值允许`默认值`：const [a, b = 1] = ['a']，当赋给的值是`undefined`的时候就会赋值为`默认值`
- 可以给一个已经定义的变量进行解构赋值，不过要用()包裹`let x; ({x} = {x: 1})`
### 数组的解构赋值
- 不完全结构也可以成功，也就是说解构一部分
- 只要有Iterator接口，就能进行数组的解构赋值
- 按照顺序进行解构赋值
### 对象的解构赋值
- 变量名与属性相同才能赋值成功
- 可以用同一个变量名取出来，再赋值为另外一个变量名，const {foo: bar} = {foo: 123}
### 字符串的解构赋值
- 用数组可以解构字符串
- 用对象可以解构字符串的length属性
### 函数的参数的解构赋值
- 解构赋值可以再函数的参数中使用
### 使用
**交换两个变量的值**
```js
let x = 1, y = 2;
[x, y] = [y, x];
```

## 字符串扩展
- es6为字符串添加Iterator接口，使得字符串能被for...of...遍历
- 模板字符串：`可以在字符串中嵌入变量`
### 字符串新增方法

### 字符串方法
